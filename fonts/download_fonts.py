#!/usr/bin/env python3
"""
Font Downloader for Text Overlay System
========================================
Downloads all 29 font families (15 English + 14 Arabic) required by the
text overlay rendering pipeline.

Sources:
  - Google Fonts  (25 families: 11 English + 14 Arabic)
    Downloaded directly from the google/fonts GitHub repository.
  - Fontshare     (4 families: 4 English)
    Downloaded via the Fontshare API (returns ZIP archives).

Usage:
    python3 fonts/download_fonts.py            # skip already-downloaded fonts
    python3 fonts/download_fonts.py --force     # re-download everything

The script is fully self-contained: only stdlib modules are used.
"""

from __future__ import annotations

import argparse
import io
import os
import re
import sys
import time
import urllib.error
import urllib.parse
import urllib.request
import zipfile
from dataclasses import dataclass, field
from pathlib import Path
from typing import Dict, List, Optional, Tuple

# ---------------------------------------------------------------------------
# Configuration
# ---------------------------------------------------------------------------

SCRIPT_DIR = Path(__file__).resolve().parent
ENGLISH_DIR = SCRIPT_DIR / "english"
ARABIC_DIR = SCRIPT_DIR / "arabic"

# Base URL for downloading .ttf files directly from the google/fonts GitHub repo
GITHUB_RAW_BASE = (
    "https://raw.githubusercontent.com/google/fonts/main"
)

FONTSHARE_URL = "https://api.fontshare.com/v2/fonts/download/{slug}"

# Maximum number of retry attempts for downloads
MAX_RETRIES = 3
RETRY_DELAY_SECONDS = 2

# Request timeout in seconds
REQUEST_TIMEOUT = 60


@dataclass
class FontSpec:
    """Describes one font family to download."""

    family: str  # Human-readable family name (e.g. "Bebas Neue")
    weights: List[str]  # Desired weights, e.g. ["Bold", "Light"]
    source: str = "google"  # "google" or "fontshare"
    slug: str = ""  # Fontshare slug (only used when source == "fontshare")
    language: str = "english"  # "english" or "arabic"

    # The canonical file-stem used in naming: spaces stripped.
    # e.g. "Bebas Neue" -> "BebasNeue"
    @property
    def stem(self) -> str:
        return self.family.replace(" ", "")

    def expected_files(self) -> List[str]:
        """Return the list of .ttf filenames we expect after download."""
        return [f"{self.stem}-{w}.ttf" for w in self.weights]


# ---------------------------------------------------------------------------
# Google Fonts GitHub repository file map
# ---------------------------------------------------------------------------
# Each entry maps a family's GitHub directory name to:
#   (license_dir, [list of .ttf filenames in the repo])
#
# Fonts fall into two categories:
#   - Static: have individual weight files (e.g. "Almarai-Bold.ttf")
#   - Variable: single file with axis tags (e.g. "Oswald[wght].ttf")
#
# For variable fonts we download the variable file and save it as
# {Stem}-Variable.ttf.  For static fonts we download the specific
# weight file and rename it to {Stem}-{Weight}.ttf.

@dataclass
class GitHubFontInfo:
    """Metadata about a font family in the google/fonts GitHub repo."""
    license_dir: str  # "ofl" or "apache"
    family_dir: str  # Directory name (lowercase, no spaces)
    files: List[str]  # TTF filenames in the repo
    is_variable: bool = False  # True if only variable font files exist

    @property
    def base_url(self) -> str:
        return f"{GITHUB_RAW_BASE}/{self.license_dir}/{self.family_dir}"


# Map from FontSpec.stem (family name without spaces) to GitHubFontInfo.
# This was generated by querying the GitHub API for actual file listings.
GITHUB_FONT_MAP: Dict[str, GitHubFontInfo] = {
    # --- English Google Fonts ---
    "BebasNeue": GitHubFontInfo(
        "ofl", "bebasneue",
        ["BebasNeue-Regular.ttf"],
    ),
    "Anton": GitHubFontInfo(
        "ofl", "anton",
        ["Anton-Regular.ttf"],
    ),
    "Oswald": GitHubFontInfo(
        "ofl", "oswald",
        ["Oswald[wght].ttf"],
        is_variable=True,
    ),
    "LeagueGothic": GitHubFontInfo(
        "ofl", "leaguegothic",
        ["LeagueGothic[wdth].ttf"],
        is_variable=True,
    ),
    "ArchivoBlack": GitHubFontInfo(
        "ofl", "archivoblack",
        ["ArchivoBlack-Regular.ttf"],
    ),
    "SpaceGrotesk": GitHubFontInfo(
        "ofl", "spacegrotesk",
        ["SpaceGrotesk[wght].ttf"],
        is_variable=True,
    ),
    "PlusJakartaSans": GitHubFontInfo(
        "ofl", "plusjakartasans",
        ["PlusJakartaSans[wght].ttf", "PlusJakartaSans-Italic[wght].ttf"],
        is_variable=True,
    ),
    "BodoniModa": GitHubFontInfo(
        "ofl", "bodonimoda",
        ["BodoniModa[opsz,wght].ttf", "BodoniModa-Italic[opsz,wght].ttf"],
        is_variable=True,
    ),
    "DMSans": GitHubFontInfo(
        "ofl", "dmsans",
        ["DMSans[opsz,wght].ttf", "DMSans-Italic[opsz,wght].ttf"],
        is_variable=True,
    ),
    "Syne": GitHubFontInfo(
        "ofl", "syne",
        ["Syne[wght].ttf"],
        is_variable=True,
    ),
    "Outfit": GitHubFontInfo(
        "ofl", "outfit",
        ["Outfit[wght].ttf"],
        is_variable=True,
    ),
    # --- Arabic Google Fonts ---
    "Almarai": GitHubFontInfo(
        "ofl", "almarai",
        ["Almarai-Bold.ttf", "Almarai-ExtraBold.ttf",
         "Almarai-Light.ttf", "Almarai-Regular.ttf"],
    ),
    "ReemKufi": GitHubFontInfo(
        "ofl", "reemkufi",
        ["ReemKufi[wght].ttf"],
        is_variable=True,
    ),
    "NotoSansArabic": GitHubFontInfo(
        "ofl", "notosansarabic",
        ["NotoSansArabic[wdth,wght].ttf"],
        is_variable=True,
    ),
    "Kufam": GitHubFontInfo(
        "ofl", "kufam",
        ["Kufam[wght].ttf", "Kufam-Italic[wght].ttf"],
        is_variable=True,
    ),
    "ElMessiri": GitHubFontInfo(
        "ofl", "elmessiri",
        ["ElMessiri[wght].ttf"],
        is_variable=True,
    ),
    "Tajawal": GitHubFontInfo(
        "ofl", "tajawal",
        ["Tajawal-Black.ttf", "Tajawal-Bold.ttf", "Tajawal-ExtraBold.ttf",
         "Tajawal-ExtraLight.ttf", "Tajawal-Light.ttf", "Tajawal-Medium.ttf",
         "Tajawal-Regular.ttf"],
    ),
    "ReadexPro": GitHubFontInfo(
        "ofl", "readexpro",
        ["ReadexPro[HEXP,wght].ttf"],
        is_variable=True,
    ),
    "IBMPlexSansArabic": GitHubFontInfo(
        "ofl", "ibmplexsansarabic",
        ["IBMPlexSansArabic-Bold.ttf", "IBMPlexSansArabic-ExtraLight.ttf",
         "IBMPlexSansArabic-Light.ttf", "IBMPlexSansArabic-Medium.ttf",
         "IBMPlexSansArabic-Regular.ttf", "IBMPlexSansArabic-SemiBold.ttf",
         "IBMPlexSansArabic-Thin.ttf"],
    ),
    "Cairo": GitHubFontInfo(
        "ofl", "cairo",
        ["Cairo[slnt,wght].ttf"],
        is_variable=True,
    ),
    "NotoKufiArabic": GitHubFontInfo(
        "ofl", "notokufiarabic",
        ["NotoKufiArabic[wght].ttf"],
        is_variable=True,
    ),
    "Lemonada": GitHubFontInfo(
        "ofl", "lemonada",
        ["Lemonada[wght].ttf"],
        is_variable=True,
    ),
    "Mada": GitHubFontInfo(
        "ofl", "mada",
        ["Mada[wght].ttf"],
        is_variable=True,
    ),
    "Changa": GitHubFontInfo(
        "ofl", "changa",
        ["Changa[wght].ttf"],
        is_variable=True,
    ),
    "BalooBhaijaan2": GitHubFontInfo(
        "ofl", "baloobhaijaan2",
        ["BalooBhaijaan2[wght].ttf"],
        is_variable=True,
    ),
}


# ---- English Google Fonts ------------------------------------------------

ENGLISH_GOOGLE: List[FontSpec] = [
    FontSpec("Bebas Neue", ["Regular"]),
    FontSpec("Anton", ["Regular"]),
    FontSpec("Oswald", ["Bold", "Light"]),
    FontSpec("League Gothic", ["Regular"]),
    FontSpec("Archivo Black", ["Regular"]),
    FontSpec("Space Grotesk", ["Bold", "Light"]),
    FontSpec("Plus Jakarta Sans", ["Bold", "Light"]),
    FontSpec("Bodoni Moda", ["Bold", "Regular"]),
    FontSpec("DM Sans", ["Bold", "Light"]),
    FontSpec("Syne", ["Bold", "Regular"]),
    FontSpec("Outfit", ["Black", "Light"]),
]

# ---- English Fontshare Fonts ---------------------------------------------

ENGLISH_FONTSHARE: List[FontSpec] = [
    FontSpec("Clash Display", ["Bold", "Light"], source="fontshare", slug="clash-display"),
    FontSpec("Satoshi", ["Bold", "Light"], source="fontshare", slug="satoshi"),
    FontSpec("General Sans", ["Bold", "Light"], source="fontshare", slug="general-sans"),
    FontSpec("Switzer", ["Bold", "Light"], source="fontshare", slug="switzer"),
]

# ---- Arabic Google Fonts -------------------------------------------------

ARABIC_GOOGLE: List[FontSpec] = [
    FontSpec("Almarai", ["Bold", "Light"], language="arabic"),
    FontSpec("Reem Kufi", ["Regular", "Bold"], language="arabic"),
    FontSpec("Noto Sans Arabic", ["Bold", "Light"], language="arabic"),
    FontSpec("Kufam", ["Bold", "Regular"], language="arabic"),
    FontSpec("El Messiri", ["Bold", "Regular"], language="arabic"),
    FontSpec("Tajawal", ["Bold", "Light"], language="arabic"),
    FontSpec("Readex Pro", ["Bold", "Light"], language="arabic"),
    FontSpec("IBM Plex Sans Arabic", ["Bold", "Light"], language="arabic"),
    FontSpec("Cairo", ["Bold", "Regular"], language="arabic"),
    FontSpec("Noto Kufi Arabic", ["Bold", "Light"], language="arabic"),
    FontSpec("Lemonada", ["Bold", "Light"], language="arabic"),
    FontSpec("Mada", ["Bold", "Regular"], language="arabic"),
    FontSpec("Changa", ["Bold", "Light"], language="arabic"),
    FontSpec("Baloo Bhaijaan 2", ["Bold", "Regular"], language="arabic"),
]

ALL_FONTS: List[FontSpec] = ENGLISH_GOOGLE + ENGLISH_FONTSHARE + ARABIC_GOOGLE

# ---------------------------------------------------------------------------
# Helpers
# ---------------------------------------------------------------------------


def ensure_dirs() -> None:
    """Create output directories if they don't already exist."""
    ENGLISH_DIR.mkdir(parents=True, exist_ok=True)
    ARABIC_DIR.mkdir(parents=True, exist_ok=True)


def output_dir_for(spec: FontSpec) -> Path:
    return ARABIC_DIR if spec.language == "arabic" else ENGLISH_DIR


def download_bytes(url: str) -> bytes:
    """Download *url* and return raw bytes, with retries."""
    headers = {
        "User-Agent": (
            "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) "
            "AppleWebKit/537.36 (KHTML, like Gecko) "
            "Chrome/120.0.0.0 Safari/537.36"
        ),
    }
    last_exc: Optional[Exception] = None
    for attempt in range(1, MAX_RETRIES + 1):
        try:
            req = urllib.request.Request(url, headers=headers)
            with urllib.request.urlopen(req, timeout=REQUEST_TIMEOUT) as resp:
                return resp.read()
        except (urllib.error.URLError, urllib.error.HTTPError, OSError) as exc:
            last_exc = exc
            if attempt < MAX_RETRIES:
                wait = RETRY_DELAY_SECONDS * attempt
                print(f"    Attempt {attempt} failed ({exc}), retrying in {wait}s ...")
                time.sleep(wait)
    raise RuntimeError(f"Download failed after {MAX_RETRIES} attempts: {last_exc}")


# ---------------------------------------------------------------------------
# Weight-matching helpers (used for Fontshare ZIP extraction)
# ---------------------------------------------------------------------------

# Map from canonical weight names to patterns that might appear in filenames.
WEIGHT_PATTERNS: Dict[str, List[str]] = {
    "Regular": ["Regular", "400"],
    "Bold": ["Bold", "700"],
    "Light": ["Light", "300"],
    "Black": ["Black", "900"],
}


def _weight_pattern(weight: str) -> re.Pattern:
    """Return a compiled regex that matches a weight token in a filename."""
    alternatives = WEIGHT_PATTERNS.get(weight, [weight])
    joined = "|".join(re.escape(a) for a in alternatives)
    return re.compile(rf"(?:[-_ ])({joined})(?:[-_.]|$)", re.IGNORECASE)


def _family_matches(filename: str, family: str) -> bool:
    """Check whether *filename* plausibly belongs to *family*."""
    def _norm(s: str) -> str:
        return re.sub(r"[\s\-_]", "", s).lower()
    return _norm(family) in _norm(filename)


# ---------------------------------------------------------------------------
# Google Fonts download (from GitHub)
# ---------------------------------------------------------------------------


def _find_static_file(info: GitHubFontInfo, stem: str, weight: str) -> Optional[str]:
    """
    For a static (non-variable) font, find the repo filename that matches
    the requested weight.

    Tries several naming conventions:
      - {Stem}-{Weight}.ttf          e.g. Almarai-Bold.ttf
      - {FamilyDir}{Weight}.ttf      (unlikely but possible)
    """
    # The most common pattern: {Stem}-{Weight}.ttf
    # where Stem matches the family name with no spaces.
    target = f"{stem}-{weight}.ttf"
    for fname in info.files:
        if fname.lower() == target.lower():
            return fname

    # Broader search: any file containing the weight name
    wpat = _weight_pattern(weight)
    for fname in info.files:
        if "[" in fname:
            continue  # skip variable font files
        if wpat.search(fname):
            return fname

    # For single-file families (e.g. Bebas Neue has only BebasNeue-Regular.ttf)
    # if there's only one non-variable file, use it
    static_files = [f for f in info.files if "[" not in f]
    if len(static_files) == 1:
        return static_files[0]

    return None


def _find_variable_file(info: GitHubFontInfo) -> Optional[str]:
    """
    Find the primary variable font file (non-italic) in the repo listing.
    """
    variable_files = [f for f in info.files if "[" in f]
    if not variable_files:
        return None

    # Prefer non-italic
    non_italic = [f for f in variable_files if "italic" not in f.lower()]
    if non_italic:
        return non_italic[0]
    return variable_files[0]


def download_google_font(spec: FontSpec, dest_dir: Path, force: bool) -> List[str]:
    """
    Download a Google Fonts family from the google/fonts GitHub repository.

    For static fonts: downloads individual weight files directly.
    For variable fonts: downloads the variable .ttf and saves as {Stem}-Variable.ttf.
    """
    info = GITHUB_FONT_MAP.get(spec.stem)
    if info is None:
        print(f"  [FAIL] {spec.family}: not found in GITHUB_FONT_MAP")
        return []

    # Check if all files already exist
    if not force:
        expected = spec.expected_files()
        all_exist = all((dest_dir / f).exists() for f in expected)
        # Also check for variable font fallback
        var_name = f"{spec.stem}-Variable.ttf"
        if not all_exist:
            all_exist = (dest_dir / var_name).exists() and all(
                (dest_dir / f).exists() or (dest_dir / var_name).exists()
                for f in expected
            )
        if all_exist:
            print(f"  [SKIP] {spec.family} -- already downloaded")
            return expected

    saved: List[str] = []

    if info.is_variable:
        # --- Variable font: download once, save as {Stem}-Variable.ttf ---
        var_target = f"{spec.stem}-Variable.ttf"
        var_path = dest_dir / var_target

        if not force and var_path.exists():
            print(f"  [SKIP] {spec.family} -- variable font already downloaded")
            return [var_target]

        var_file = _find_variable_file(info)
        if var_file is None:
            print(f"  [FAIL] {spec.family}: no variable font file found in repo listing")
            return []

        # URL-encode the filename (brackets need encoding)
        encoded_name = urllib.parse.quote(var_file)
        url = f"{info.base_url}/{encoded_name}"
        print(f"  [DOWN] {spec.family} (variable: {', '.join(spec.weights)})")
        print(f"         {url}")

        try:
            data = download_bytes(url)
        except RuntimeError as exc:
            print(f"  [FAIL] {spec.family}: {exc}")
            return []

        # Verify it looks like a font file (TTF magic: 0x00010000 or 'true')
        if len(data) < 4:
            print(f"  [FAIL] {spec.family}: downloaded file too small ({len(data)} bytes)")
            return []

        var_path.write_bytes(data)
        print(f"    Saved: {var_target} ({len(data):,} bytes)")
        saved.append(var_target)

    else:
        # --- Static font: download each weight individually ---
        print(f"  [DOWN] {spec.family} ({', '.join(spec.weights)})")

        for weight in spec.weights:
            target_name = f"{spec.stem}-{weight}.ttf"
            target_path = dest_dir / target_name

            if not force and target_path.exists():
                print(f"    Already exists: {target_name}")
                saved.append(target_name)
                continue

            repo_filename = _find_static_file(info, spec.stem, weight)
            if repo_filename is None:
                print(f"    WARNING: Could not find weight '{weight}' for {spec.family}")
                print(f"             Available files: {info.files}")
                continue

            url = f"{info.base_url}/{repo_filename}"
            print(f"         {url}")

            try:
                data = download_bytes(url)
            except RuntimeError as exc:
                print(f"    FAIL ({weight}): {exc}")
                continue

            if len(data) < 4:
                print(f"    FAIL ({weight}): downloaded file too small ({len(data)} bytes)")
                continue

            target_path.write_bytes(data)
            print(f"    Saved: {target_name} ({len(data):,} bytes)")
            saved.append(target_name)

    return saved


# ---------------------------------------------------------------------------
# Fontshare download (ZIP-based, unchanged)
# ---------------------------------------------------------------------------


def extract_fontshare_fonts(
    zip_data: bytes,
    spec: FontSpec,
    dest_dir: Path,
) -> List[str]:
    """
    Fontshare zips have a directory structure like:
        <FontName>_Complete/Fonts/TTF/<Variable>.ttf
        <FontName>_Complete/Fonts/WEB/fonts/<Weight>.ttf

    The TTF/ directory typically contains only variable fonts.
    Individual weight files (.ttf) are in WEB/fonts/.
    We search all .ttf files in the zip and match by weight.
    """
    saved: List[str] = []

    with zipfile.ZipFile(io.BytesIO(zip_data)) as zf:
        all_entries = zf.namelist()

        # Collect ALL .ttf files (excluding macOS resource forks)
        all_ttf = [
            n for n in all_entries
            if n.lower().endswith(".ttf") and not n.startswith("__MACOSX")
        ]

        # Exclude variable font files from the search pool for weight matching
        static_ttf = [
            n for n in all_ttf
            if "variable" not in os.path.basename(n).lower()
        ]

        # Use static files if available; fall back to all TTF files
        search_pool = static_ttf if static_ttf else all_ttf

        if not search_pool:
            # Try .otf as last resort
            all_otf = [
                n for n in all_entries
                if n.lower().endswith(".otf") and not n.startswith("__MACOSX")
            ]
            otf_dir_files = [n for n in all_otf if "/otf/" in n.lower()]
            if otf_dir_files or all_otf:
                print(f"    WARNING: No .ttf files found for {spec.family}; .otf files available but not used.")
            else:
                print(f"    WARNING: No font files found in zip for {spec.family}")
            return saved

        for weight in spec.weights:
            target_name = f"{spec.stem}-{weight}.ttf"
            target_path = dest_dir / target_name

            wpat = _weight_pattern(weight)
            candidates = [
                n for n in search_pool
                if wpat.search(os.path.basename(n))
            ]

            # Further filter: prefer files matching the family name
            family_filtered = [
                c for c in candidates
                if _family_matches(os.path.basename(c), spec.family)
            ]
            if family_filtered:
                candidates = family_filtered

            if candidates:
                chosen = min(candidates, key=len)
                data = zf.read(chosen)
                target_path.write_bytes(data)
                saved.append(target_name)
            else:
                print(f"    WARNING: Could not find weight '{weight}' for {spec.family} (Fontshare)")

    return saved


def download_fontshare_font(spec: FontSpec, dest_dir: Path, force: bool) -> List[str]:
    """Download a Fontshare family and extract the desired weights."""
    if not force:
        expected = spec.expected_files()
        if all((dest_dir / f).exists() for f in expected):
            print(f"  [SKIP] {spec.family} -- already downloaded")
            return expected

    url = FONTSHARE_URL.format(slug=spec.slug)
    print(f"  [DOWN] {spec.family} ({', '.join(spec.weights)})")
    print(f"         URL: {url}")

    try:
        data = download_bytes(url)
    except RuntimeError as exc:
        print(f"  [FAIL] {spec.family}: {exc}")
        return []

    return extract_fontshare_fonts(data, spec, dest_dir)


# ---------------------------------------------------------------------------
# Verification & summary
# ---------------------------------------------------------------------------


def verify_and_summarise(results: Dict[str, List[str]]) -> bool:
    """
    Print a table of results and return True if every expected font was
    downloaded successfully.
    """
    total_expected = 0
    total_found = 0
    missing: List[Tuple[str, str]] = []

    print("\n" + "=" * 70)
    print("DOWNLOAD SUMMARY")
    print("=" * 70)

    for spec in ALL_FONTS:
        dest = output_dir_for(spec)
        expected = spec.expected_files()

        for fname in expected:
            total_expected += 1
            fpath = dest / fname
            var_path = dest / f"{spec.stem}-Variable.ttf"
            if fpath.exists():
                total_found += 1
            elif var_path.exists():
                # Variable font covers this weight
                total_found += 1
            else:
                missing.append((spec.family, fname))

    print(f"\nTotal font files expected : {total_expected}")
    print(f"Total font files present  : {total_found}")

    if missing:
        print(f"\nMISSING ({len(missing)}):")
        for family, fname in missing:
            print(f"  - {family}: {fname}")
        print()
        return False
    else:
        print("\nAll font files are present.\n")
        return True


# ---------------------------------------------------------------------------
# Main
# ---------------------------------------------------------------------------


def main() -> None:
    parser = argparse.ArgumentParser(
        description="Download fonts for the text overlay system.",
    )
    parser.add_argument(
        "--force",
        action="store_true",
        help="Re-download fonts even if they already exist.",
    )
    args = parser.parse_args()

    ensure_dirs()

    results: Dict[str, List[str]] = {}

    # ---- English Google Fonts ----
    print("\n--- English Fonts (Google Fonts via GitHub) ---\n")
    for spec in ENGLISH_GOOGLE:
        key = f"{spec.language}/{spec.family}"
        saved = download_google_font(spec, ENGLISH_DIR, force=args.force)
        results[key] = saved

    # ---- English Fontshare Fonts ----
    print("\n--- English Fonts (Fontshare) ---\n")
    for spec in ENGLISH_FONTSHARE:
        key = f"{spec.language}/{spec.family}"
        saved = download_fontshare_font(spec, ENGLISH_DIR, force=args.force)
        results[key] = saved

    # ---- Arabic Google Fonts ----
    print("\n--- Arabic Fonts (Google Fonts via GitHub) ---\n")
    for spec in ARABIC_GOOGLE:
        key = f"{spec.language}/{spec.family}"
        saved = download_google_font(spec, ARABIC_DIR, force=args.force)
        results[key] = saved

    # ---- Verify ----
    all_ok = verify_and_summarise(results)
    if not all_ok:
        print("Some fonts are missing. You may need to download them manually.")
        sys.exit(1)
    else:
        print("Font download complete.")
        sys.exit(0)


if __name__ == "__main__":
    main()
